package com.openclassrooms.mddapi.service;

import com.openclassrooms.mddapi.dto.SubjectDTO;
import com.openclassrooms.mddapi.entity.Subject;
import com.openclassrooms.mddapi.entity.User;
import com.openclassrooms.mddapi.mapper.SubjectMapper;
import com.openclassrooms.mddapi.repository.SubjectRepository;
import com.openclassrooms.mddapi.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.persistence.EntityNotFoundException;

/**
 * Service m√©tier Subject - MVP STRICT.
 *
 * **FONCTIONNALIT√âS MVP UNIQUEMENT :**
 * - Affichage des sujets pour utilisateurs connect√©s
 * - Abonnement/d√©sabonnement d'un utilisateur √† un sujet
 * - Pagination simple
 *
 * @author √âquipe MDD
 * @version 1.0
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class SubjectService {

    private final SubjectRepository subjectRepository;
    private final UserRepository userRepository;
    private final SubjectMapper subjectMapper;

    /**
     * R√©cup√®re tous les sujets avec statut d'abonnement pour l'utilisateur connect√©.
     *
     * @param userEmail email de l'utilisateur connect√©
     * @param page num√©ro de page
     * @param size taille de page
     * @return Page de SubjectDTO avec statut d'abonnement
     */
    public Page<SubjectDTO> getAllSubjects(String userEmail, int page, int size) {
        log.debug("üìÑ Liste sujets pour: {} - Page: {}, Size: {}", userEmail, page, size);

        // R√©cup√©ration utilisateur connect√©
        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new EntityNotFoundException("Utilisateur non trouv√©: " + userEmail));

        Pageable pageable = PageRequest.of(page, size);
        Page<Subject> subjectsPage = subjectRepository.findAllByOrderByNameAsc(pageable);

        // Conversion avec statut d'abonnement
        return subjectsPage.map(subject -> {
            SubjectDTO dto = subjectMapper.toDTO(subject);
            dto.setIsSubscribed(subjectRepository.isUserSubscribedToSubject(subject.getId(), user.getId()));
            return dto;
        });
    }

    /**
     * R√©cup√®re un sujet par son ID avec statut d'abonnement.
     *
     * @param id ID du sujet
     * @param userEmail email de l'utilisateur connect√©
     * @return SubjectDTO avec statut d'abonnement
     */
    public SubjectDTO getSubjectById(Long id, String userEmail) {
        log.debug("üîç Recherche sujet ID: {} pour: {}", id, userEmail);

        Subject subject = subjectRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Sujet non trouv√© avec ID: " + id));

        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new EntityNotFoundException("Utilisateur non trouv√©: " + userEmail));

        SubjectDTO dto = subjectMapper.toDTO(subject);
        dto.setIsSubscribed(subjectRepository.isUserSubscribedToSubject(id, user.getId()));

        return dto;
    }

    /**
     * Abonne un utilisateur √† un sujet.
     *
     * @param subjectId ID du sujet
     * @param userEmail email de l'utilisateur connect√©
     * @throws IllegalStateException si d√©j√† abonn√©
     */
    @Transactional
    public void subscribeToSubject(Long subjectId, String userEmail) {
        log.info("üìå Abonnement sujet ID: {} par: {}", subjectId, userEmail);

        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new EntityNotFoundException("Utilisateur non trouv√©: " + userEmail));

        Subject subject = subjectRepository.findById(subjectId)
                .orElseThrow(() -> new EntityNotFoundException("Sujet non trouv√© avec ID: " + subjectId));

        // V√©rification si d√©j√† abonn√©
        if (subjectRepository.isUserSubscribedToSubject(subjectId, user.getId())) {
            throw new IllegalStateException("Vous √™tes d√©j√† abonn√© √† ce sujet");
        }

        // Ajout de l'abonnement
        user.getSubscribedSubjects().add(subject);
        userRepository.save(user);

        log.info("‚úÖ Abonn√© √† '{}' par {}", subject.getName(), userEmail);
    }

    /**
     * D√©sabonne un utilisateur d'un sujet.
     *
     * @param subjectId ID du sujet
     * @param userEmail email de l'utilisateur connect√©
     * @throws IllegalStateException si pas abonn√©
     */
    @Transactional
    public void unsubscribeFromSubject(Long subjectId, String userEmail) {
        log.info("üìå D√©sabonnement sujet ID: {} par: {}", subjectId, userEmail);

        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new EntityNotFoundException("Utilisateur non trouv√©: " + userEmail));

        Subject subject = subjectRepository.findById(subjectId)
                .orElseThrow(() -> new EntityNotFoundException("Sujet non trouv√© avec ID: " + subjectId));

        // V√©rification si abonn√©
        if (!subjectRepository.isUserSubscribedToSubject(subjectId, user.getId())) {
            throw new IllegalStateException("Vous n'√™tes pas abonn√© √† ce sujet");
        }

        // Suppression de l'abonnement
        user.getSubscribedSubjects().remove(subject);
        userRepository.save(user);

        log.info("‚úÖ D√©sabonn√© de '{}' par {}", subject.getName(), userEmail);
    }

    /**
     * Check if a subject name already exists.
     *
     * @param name subject name to check
     * @return true if exists, false otherwise
     */
    public boolean existsByName(String name) {
        log.debug("üîç V√©rification existence nom sujet: {}", name);
        return subjectRepository.existsByNameIgnoreCase(name);
    }

    /**
     * Create a new subject.
     *
     * @param subjectDTO subject data
     * @return created subject DTO
     */
    @Transactional
    public SubjectDTO createSubject(SubjectDTO subjectDTO) {
        log.info("üìù Cr√©ation sujet: {}", subjectDTO.getName());

        // Check if name already exists
        if (existsByName(subjectDTO.getName())) {
            throw new IllegalStateException("Un sujet avec ce nom existe d√©j√†");
        }

        Subject subject = subjectMapper.toEntity(subjectDTO);
        Subject savedSubject = subjectRepository.save(subject);

        log.info("‚úÖ Sujet cr√©√©: '{}' (ID: {})", savedSubject.getName(), savedSubject.getId());
        return subjectMapper.toDTO(savedSubject);
    }

    /**
     * Update an existing subject.
     *
     * @param id subject ID
     * @param subjectDTO updated subject data
     * @return updated subject DTO
     */
    @Transactional
    public SubjectDTO updateSubject(Long id, SubjectDTO subjectDTO) {
        log.info("üîÑ Mise √† jour sujet ID: {}", id);

        Subject subject = subjectRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Sujet non trouv√© avec ID: " + id));

        // Check if new name already exists (if changed)
        if (!subject.getName().equalsIgnoreCase(subjectDTO.getName()) && 
            existsByName(subjectDTO.getName())) {
            throw new IllegalStateException("Un sujet avec ce nom existe d√©j√†");
        }

        subject.setName(subjectDTO.getName());
        Subject updatedSubject = subjectRepository.save(subject);

        log.info("‚úÖ Sujet mis √† jour: '{}' (ID: {})", updatedSubject.getName(), id);
        return subjectMapper.toDTO(updatedSubject);
    }

    /**
     * Delete a subject.
     *
     * @param id subject ID
     */
    @Transactional
    public void deleteSubject(Long id) {
        log.info("üóëÔ∏è Suppression sujet ID: {}", id);

        Subject subject = subjectRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Sujet non trouv√© avec ID: " + id));

        // Check if subject has articles
        if (subjectRepository.countArticlesBySubjectId(id) > 0) {
            throw new IllegalStateException("Impossible de supprimer un sujet qui contient des articles");
        }

        subjectRepository.delete(subject);
        log.info("‚úÖ Sujet supprim√©: '{}' (ID: {})", subject.getName(), id);
    }
}